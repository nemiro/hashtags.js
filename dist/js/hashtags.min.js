(function(window){
  "use strict";

  function HtUtils() {
  }

  /**
   *
   * @param {HTMLElement} el
   * @param {string} clName
   * @param {number} [limit]
   * @returns {HTMLElement}
   */
  HtUtils.prototype.getClosestByClass = function htuGetClosest(el, clName, limit) {
    limit = limit || parseInt(limit) || -1;
    while (limit !== 0) {
      if (this.hasClass(el, clName)) return el;
      if (--limit === 0) return null;
      el = el.parentNode;
    }
    return null;
  };

  /**
   *
   * @param el
   * @param clName
   * @returns {boolean}
   */
  HtUtils.prototype.hasClass = function htuHasCls(el, clName) {
    if (!el || !el.className) return false;
    return (' ' + el.className + ' ').indexOf(' ' + clName + ' ') >= 0;
  };

  /**
   *
   * @param el
   * @param clName
   * @private
   */
  HtUtils.prototype.addClass = function htuAddCls(el, clName) {
    el.className += ' ' + clName;
  };

  /**
   *
   * @param el
   * @param clName
   * @private
   */
  HtUtils.prototype.removeClass = function htuRemCls(el, clName) {
    el.className = el.className.replace(new RegExp('[\\s]*' + clName + '[\\s]*', 'g'), '');
  };

  /**
   * @see http://stackoverflow.com/questions/10149963/adding-event-listener-cross-browser
   * add event cross browser
   *
   * @param elem
   * @param event
   * @param fn
   */
  HtUtils.prototype.addEvent = function htuAddEvent(elem, event, fn) {
    // avoid memory overhead of new anonymous functions for every event handler that's installed
    // by using local functions
    function listenHandler(e) {
      var ret = fn.apply(this, arguments);
      if (ret === false) {
        e.stopPropagation();
        e.preventDefault();
      }
      return (ret);
    }

    function attachHandler() {
      // set the this pointer same as addEventListener when fn is called
      // and make sure the event is passed to the fn also so that works the same too
      var ret = fn.call(elem, window.event);
      if (ret === false) {
        window.event.returnValue = false;
        window.event.cancelBubble = true;
      }
      return (ret);
    }

    if (elem.addEventListener) {
      elem.addEventListener(event, listenHandler, false);
    } else {
      elem.attachEvent("on" + event, attachHandler);
    }
  };

  /**
   * @see https://gist.github.com/dciccale/6226151
   *
   * @param target
   * @param type
   * @param event
   * @private
   */
  HtUtils.prototype.triggerEvent = function htuTriggerEvent(target, type, event) {

    var doc = document;
    if (doc.createEvent) {
      event = new Event(type);
      target.dispatchEvent(event);
    } else if (document.createEventObject) {
      event = doc.createEventObject();
      target.fireEvent('on' + type, event);
    }
    /* else if (typeof target['on' + type] == 'function' ) {
     target['on' + type]();
     } else if (typeof target[type] == 'function' ) {
     target[type]();
     }/**/
  };

  /**
   *
   * @param oElm
   * @param css3Prop
   * @returns {string}
   */
  HtUtils.prototype.getStyle = function htuGetElStyle(oElm, css3Prop){
    var strValue = "";

    if(window.getComputedStyle){
      strValue = getComputedStyle(oElm).getPropertyValue(css3Prop);
    }
    //IE
    else if (oElm.currentStyle){
      try {
        strValue = oElm.currentStyle[css3Prop];
      } catch (e) {}
    }

    return strValue;
  };

  window.htUtils = new HtUtils();

})(window);
"use strict";

/**
*
* @param {string} value
* @param {Object} [params]
* @constructor
*/
function HtTag(value, params){
  this.value = value;

  // extend params if specified
  if( typeof(params) === 'object' ) {
    for(var k in params) {
      if(!params.hasOwnProperty(k)) continue;
      this.params[k] = params[k];
    }
  }
}

/**
*
* @type {Object}
*/
HtTag.prototype.params = {
  cssTag     : 'ht-hashtag',
  cssLabel   : 'ht-hashtag-label',
  cssValue   : 'ht-hashtag-value',
  cssActions : 'ht-hashtag-actions',
  cssActRemove  : 'ht-hashtag-remove'
};

/**
*
* @type {string}
*/
HtTag.prototype.value = null;

/**
 *
 * @type {HTMLElement}
 * @private
 */
HtTag.prototype._node = null;

/**
*
* @param {string} tagName
* @returns {HTMLElement}
* @private
*/
HtTag.prototype._ces = function(tagName){
  return document.createElement( tagName || 'span');
};

/**
*
* @returns {string}
*/
HtTag.prototype.toString = function tagToString(){
  return this.value;
};

/**
*
* @returns {HTMLElement}
*/
HtTag.prototype.getNode = function tagToString( nodeClass ){
  if(!this._node) this._node = this.generateNode();
  if( nodeClass === void 0 ) return this._node;
  var k, node, cn = this._node.childNodes;
  for(k in cn) {
    if(!cn.hasOwnProperty(k)) continue;
    node = cn[k];
    if( node.className.indexOf(nodeClass) === 0 ) {
      return node;
    }
  }
  return null;
};

/**
 *
 * @param {string} value
 */
HtTag.prototype.setValue = function tagSetValue(value){
  var node = this.getNode(this.params.cssValue);
  node.textContent = node.innerText = this.value = value;
};

/**
*
* @returns {HTMLElement}
*/
HtTag.prototype.generateNode = function tagGenNode(){
  var
    _ces = this._ces,
    params = this.params,
    node = _ces(),
    label = _ces(),
    value = _ces(),
    actions = this._generateActionsNode()
  ;

  // set classes
  node.className  = params.cssTag;
  label.className = params.cssLabel;
  value.className = params.cssValue;

  // set value
  value.textContent = value.innerText = this.value;

  // append sub-nodes to main node
  node.appendChild(label);
  node.appendChild(value);
  node.appendChild(actions);

  node.tag = this;

  return node;
};

/**
 *
 */
HtTag.prototype.focus = function() {
  htUtils.addClass(this.getNode(), 'ht-hashtag--focused');
};

/**
 *
 */
HtTag.prototype.blur = function() {
  htUtils.removeClass(this.getNode(), 'ht-hashtag--focused');
};

/**
 *
 * @private
 * @returns {HTMLElement}
 */
HtTag.prototype._generateActionsNode = function tagActionNode() {
  var
    _ces = this._ces,
    params = this.params,
    node = _ces(),
    remove = _ces()
  ;

  node.className   = params.cssActions;
  remove.className = params.cssActRemove;

  node.appendChild(remove);

  return node;
};
"use strict";

/**
 *
 * @constructor
 */
function HashTags(){this.init.apply(this, arguments);/**/}

/**
*
* @public
* @type {Object}
*/
HashTags.prototype = {
  /**
   *
   */
  constructor : HashTags,

  /**
   *
   */
  defaultOptions : {
      value : '',
      label : '#',
      separator : ' ',
      removeBtn : true,
      copyStyle : true,
      inputMinWidth : 50,
      inputMaxWidth : 0,
      inputMaxLength : 0,
      inputPlaceholder : '',
      invalidChars : new RegExp('[^\\s\\w-]+','gi'),
      styleAttrs : [
          'background',
          'color',
          'border',
          'padding',
          'margin'
      ]
  },

  /**
   * @type {HtTag}
   */
  tag : null,

  /**
   * @type {Array<HtTag>}
   */
  tags : [],

  /**
   * @type {HTMLElement}
   */
  target : null,

  /**
   * @type {HTMLElement}
   */
  container : null,

  /**
   * @type {HTMLElement}
   */
  input : null,

  /**
   * @type {Object}
   */
  options : {},

  /**
   *
   * @param {HTMLElement} el
   * @param {Object} [options]
   */
  init : function( el, options ) {

      if( !(el instanceof HTMLElement) ) {
          console.warn('wrong element', el);
          this.log('HashTags element not instance of the HTMLElement');
          return;
      }

      if( typeof(options) !== 'object' ) {
          options = {};
      }

      if( options.value !== void 0 ) {
          this.tags = this.extract(options.value);
      }

      // extend options
      var k, defOpts = this.defaultOptions;
      for(k in defOpts) {
        if(!defOpts.hasOwnProperty(k)) continue;
        if(options[k] === void 0) {
            options[k] = defOpts[k];
        }
      }

      this.options = options;

      this.target = el;

      this.container = this.generateContainer(el);
      this.input = this.generateInput();
      this.container.appendChild(this.input);

      this.bindEvents();
      this.resizeInput();
      //this.setUp();

  },

  bindEvents : function htBindEvents() {

    htUtils.addEvent(this.container, 'click', function(ev) {
      ev = ev || window.event;
      var targ = ev.target;
      if(!targ) return;
      if( targ == this.container ) {
        this.input.focus();
        //this._triggerEvent(this.input, 'focus');
        return;
      }
      var htClName = 'ht-hashtag';
      var htTag = htUtils.getClosestByClass(targ, htClName, 3);
      if( htTag ) {
        this.setTag(htTag.tag);
        return;
      }
    }.bind(this));

  },

  //setUp : function hashtagsSetup() {
  //
  //    this.container.classList.add('ht-hashtags-container');
  //
  //    var tags = this.value.split(this.options.separator);
  //
  //    console.warn('tags', tags);
  //
  //},

  /**
   *
   * @param {string} str
   */
  push : function htPushString(str){

    // replace not valid characters
    var invalidChars = this.options.invalidChars;
    if( invalidChars instanceof RegExp ) {
      str = (str+'').replace(invalidChars,'');
    }

    // trim spaces
    str = (str+'').trim();
    if(!str.length) return;

    var i = 0, tags = this.extract(str), ii = tags.length;
    var defaultTagParams = {}; // TODO
    for(;i<ii;++i) this.addTag(new HtTag(tags[i], defaultTagParams));
  },

  /**
   *
   * @param {string} str
   * @returns {Array}
   */
  extract : function htExtract(str) {
    return ((str||'')+'').split(this.getSeparator());
  },

  /**
   *
   * @param {HtTag} tag
   */
  addTag : function htAddTag(tag) {
    if( !(tag instanceof HtTag) ) return;
    this.container.appendChild(tag.getNode());
    this.container.appendChild(this.input); // append input to end
    this.tags.push(tag);
    this.resizeInput();
  },

  /**
   *
   * @returns {Array.<HtTag>}
   */
  getTags : function htGetTags() {
    return this.tags;
  },

  /**
   *
   * @returns {string}
   */
  getValue : function htGetValue() {
    return this.tags.join(this.getSeparator());
  },

  /**
   *
   * @returns {string}
   */
  getSeparator : function htGetSep(){
    return this.options.separator;
  },

  /**
   *
   * @param {string} sep
   */
  setSeparator : function htSetSep(sep) {
    this.options.separator = sep + '';
  },

  /**
   *
   * @param {HtTag} tag
   */
  setTag : function htSetTag(tag) {
    if(!(tag instanceof HtTag)) return;
    this.unsetTag();
    this.tag = tag;
    tag.focus();
  },

  /**
   *
   */
  unsetTag : function htUnsetTag() {
    if(this.tag) this.tag.blur();
  },

  /**
  *
  * @param {HTMLElement} sourceEl
  * @returns {HTMLElement}
  */
  generateContainer : function(sourceEl) {

      if( sourceEl.nodeName.toLowerCase() !== 'input' ) {

          if( this.value === null ) {
              this.value = sourceEl.textContent || sourceEl.innerText;
          }

          return sourceEl;
      }

    throw new Error('clone input not implemented yet');
      //return this.cloneInput(sourceEl);
  },

  /**
   *
   * @returns {HTMLElement}
   */
  generateInput : function htGenInput() {
    var opt = this.options;
    var input = document.createElement('input');
    input.className = 'ht-hashtag-input';

    var maxLength = opt.inputMaxLength;
    if( maxLength > 1 ) {
      input.maxLength = maxLength;
    }

    var placeholder = opt.inputPlaceholder;
    if( placeholder ) {
      input.placeholder = placeholder;
    }

    htUtils.addEvent(input, 'focus', function() {
      this.unsetTag();
      htUtils.addClass(this.container, 'ht-hashtag-container--focused');
    }.bind(this));
    htUtils.addEvent(input, 'blur', function() {
      htUtils.removeClass(this.container, 'ht-hashtag-container--focused');
    }.bind(this));
    htUtils.addEvent(input, 'keyup', function() {
      var val = input.value;
      if( val.indexOf(this.getSeparator()) !== -1 ) {
        var i = 0, values = this.extract(val), ii = values.length;
        for(;i<ii-1;++i) this.push(values[i]);
        input.value = values[ii]||'';
        input.focus();
      }
    }.bind(this));

    return input;
  },

  /**
   *
   */
  resizeInput : function htResizeInput() {

    var width, contPadding = 0, inp = this.input,
      cont = this.container, opt = this.options,
      contWidth;

    // container padding
    contPadding += +(htUtils.getStyle(cont, 'padding-left')||'').split('px').shift();
    contPadding += +(htUtils.getStyle(cont, 'padding-right')||'').split('px').shift();
    contWidth = cont.offsetWidth - contPadding;

    // reset width
    inp.style.width = 0;

    // calculate new width
    width = contWidth - inp.offsetLeft;

    // correct width
    if( opt.inputMinWidth > width ) {
      // if width is smaller, that min width,
      // than input will be on new row,
      // so set it the whole width of container
      width = contWidth;
    }
    if( opt.inputMaxWidth ) {
      // limit max width
      width = Math.min(width, opt.inputMaxWidth);
      // because cont can have smaller width,
      // than max width option
      width = Math.min(width, contWidth);
    }

    // set new width
    inp.style.width = width + 'px';
  },

  ///**
  // *
  // * @param {HTMLElement} inputEl
  // * @returns {HTMLElement}
  // */
  //cloneInput : function( inputEl ) {
  //
  //    var container,
  //        opts = this.options;
  //
  //    // generate container
  //    container = document.createElement('div');
  //
  //    if( opts.copyStyle ) {
  //        // copy input style
  //        if( inputEl.getAttribute('type') == 'text') {
  //            // copy width
  //            container.style.width = inputEl.offsetWidth;
  //        }
  //
  //        // copy style attrs
  //        var computedStyle = window.getComputedStyle(inputEl, null);
  //        var i = 0, k, s, attrs = opts.styleAttrs, ii = attrs.length;
  //        for(;i<ii;++i) {
  //            k=attrs[i];
  //            if(s=computedStyle[k]) {
  //                container.style[k] = s;
  //            }
  //        }
  //    }
  //
  //    if(this.value === null) {
  //        this.value = inputEl.value;
  //    }
  //
  //    // append container to DOM
  //    inputEl.parentNode.insertBefore(container, inputEl);
  //
  //    return container;
  //},

  /**
   *
   * @param {String} msg
   */
  log : function( msg ) {
      if(!window.console) alert(msg);
      else if(!console.error) console.log(msg);
      else console.error(msg);
  }
};

////////////////////
// export

if(window.jQuery) {
    /**
     *
     * @returns {jQuery}
     */
    window.jQuery.fn.hashtags = function() {
        var $el = $(this);
        if(!$el.data('hashtags') ) {
            $el.data('hashtags', new HashTags(this));
        }
        return $el;
    };
}

window.module = window.module || {};
module.exports = HashTags;
//# sourceMappingURL=hashtags.min.js.map